# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Иванопуло А.Б.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта я:

1. Разберусь со структурой файлов типа GEDCOM;
2. Освежу свои знания по регулярным выражениям и языку Python в процессе написания парсера;
3. Повторю теоретические основы для поиска в пространстве состояний;
4. Улучшу своё понимание логического программирования и программирования в целом.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: с использованием предикатов parent(родитель, ребенок), sex(человек, m/f)
 3. Реализовать предикат проверки/поиска шурина
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Так как у меня не было времени на создание своего родословного дерева, я взял родословное дерево европейской знати. Однако количество записей в этом дереве очень большое, поэтому было решено следующее: сначала взять случайного человека, и потом брать всех его потомков до тех пор, пока не будет превышено некоторое значение (в данном случае 200), и повторять такое до тех пор, пока опять же не будет превышено это же значение (то есть берем случайного человека, у него мало потомков => берем следующего случайного человека и так далее). Для меня парсер выбрал семью из 211 человек.

## Конвертация родословного дерева

Был выбран Python, поскольку на нем можно очень просто с помощью регулярных выражений написать парсер.
Прежде чем выбрать семью, я прохожусь по gedcom'у и для каждой записи, начинающийся со строчки вида "0 @ID@ INDI", я загружаю в память нужную мне информацию (пол "1 SEX M\F", имя "1 NAME имя"). Далее идут записи семей, в каждой семье я записываю айди жены, мужа и детей, и записываю в children[wife] и children[husband] список детей. И только потом по описанному выше алгоритму я выбираю небольшую семью и записываю их данные в виде фактов sex(X, m\f) parent(P, C) на прологе.

[листинг кода парсера](https://github.com/MAILabs-Education-LP/lp-capstone-alexLopatin/blob/master/parser.py)

## Предикат поиска родственника


Требуется реализовать предикат проверки/поиска шурина (брата жены). Для начала, я определю предикат, который проверяет, являюся ли два человека братом или сестрой, и предикат, который проверяет, женаты ли два человека:

```prolog
married(H, W):-
    parent(H, C), 
    sex(H, 'M'),
    parent(W, C),
    sex(W, 'F').

sibling(X,Y):-
    parent(Z, X),
    parent(Z, Y),
    X \= Y.
```
Чтобы выяснить, является ли один человек другому шурином, нужно определить, есть ли у второго человека жена, у которой брат - первый человек:

```prolog
brotherInLaw(B, X):-
    married(X, W),
    sex(W, 'F'),
    sibling(B, W),
    sex(B, 'M').
```
Пример работы предиката:

```prolog
?- brotherInLaw(X,Y).
X = 'Генрих дез /Плейззенлендес/',
Y = 'Генрих II фон /Брауншвейг-Грубенхаген/'
X = 'Фридрих I /Мейсенский/',
Y = 'Генрих II фон /Брауншвейг-Грубенхаген/'
X = 'Дицман /Мейсенский/',
Y = 'Генрих II фон /Брауншвейг-Грубенхаген/'
X = 'Альбрехт /Мейсенский/',
Y = 'Генрих II фон /Брауншвейг-Грубенхаген/'
X = 'Иоанн /Комнин/',
Y = 'Леопольд VI /Австрийский/'
X = 'Алексей /Комнин/',
Y = 'Леопольд VI /Австрийский/'
...
```

## Определение степени родства

Чтобы найти кратчайшее отношение родства, я использую поиск в ширину. Сначала я определил предикат близкого родства relationship (жена, муж, отец, мать, сын, дочь, брат, сестра). Граф родословного дерева выглядит следующим образом: вершины - люди, а связи между ними - отношение близкого родства. Далее я нахожу кратчайшую цепочку людей, через которых связаны два человека и переворачиваю её (так как в путь добавляются вершины в обратном порядке). Теперь мне дана цепочка людей, и можно запросто преобразовать эту цепочку родственников в цепочку отношений:

```prolog
relations([X,Y|T], R, L):-
    relationship(RS, X, Y),
    relations([Y|T], [RS|R], L).

relations([_], L,L).
```
Код предиката relative:

```prolog
relative(X, Y, L):-
    search(X, Y, P),
	relations(P, [], L).
```
Результат работы:

```prolog
?- relative('Маргарита Маульташ /Каринтийская/','Агнесса /Мейсенская/',R).
R = [daughter, daughter]
false
```
То есть, Маргарита является дочью дочери Агнессы (проще говоря она её внучка).
## Выводы

В результате изучения логического программирования я углубил свои знания не только в логической парадигме, на и в императивной, и в целом я посмотрел на программирования под другим углом. До этого я даже не мог подумать, что программы можно писать не в виде порядка действий, которого должен придерживаться компьютер, а в виде описания "мира" поставленной задачи, выделения её свойств и так далее.

Жаль, что не получилось узнать о логическом программировании раньше, на 2 курсе, ведь это действительно полезный опыт, который поможет любому, кто хочет стать профессиональным программистом.

