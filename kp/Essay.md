# Реферат
## по курсу "Логическое программирование"

### студент: Иванопуло А.Б.

## Как научить вашу бабушку/дедушку логическому программированию 

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

### Предисловие
Наш мир очень сильно изменился за последние 30 лет: когда-то давно персональные компьютеры были роскошью, а средняя скорость передачи данных по сети интернет не превосходила нескольких килобит в секунду. Теперь же почти у каждого в кармане находится компактное беспроводное устройство — смартфон, которое во многих аспектах не уступает некоторым персональным компьютерам, а благодаря глобальной спутниковой сети Starlink в течение следующих пары лет высокоскоростной интернет будет доступен из любой точки на Земле за относительно невысокую цену.  Глобальная сеть помогает нам на работе, в общении с родными и близкими, школьникам и студентам – в учебе. Если раньше надо было потратить много времени для поиска нужной информации, то сейчас это можно сделать легко и быстро. В 21-ом веке, ознаменованном веком информационных технологий умение обращаться с компьютером особенно важный навык в повседневной жизни. Так почему бы не научиться общаться с компьютером на его языке? И почему стоит выбрать именно язык логического программирования? И, основная тема данного реферата, как научить старшее поколение (бабушку или дедушку) логическому программированию? Стоит оговориться, подобная задача довольно непроста, особенно если у дедушки или бабушки нет высшего образования. Поэтому я начну объяснять с самых азов, и буду формулировать такие вопросы, какие бы мне задали бабушка или дедушка по рассказываемому им мной материалу и отвечать на них. Для этого мне нужно поставить себя на их место и «попытаться» полностью забыть материал. На самом деле это очень полезно, ведь это в первую очередь способствует развитию моих педагогических навыков.
### Программирование
Сначала, конечно же, нужно объяснить, зачем вообще нужно программирование. Уметь программировать — это очень важный навык, который способствует развитию логичного и последовательного мышления. С помощью программирования мы можем значительно упростить работу за компьютером. Например, с помощью Excel (программирование на ячейках) можно запрограммировать рекуррентную (можно сказать повторяющуюся) формулу для вычисления какого-либо столбца в таблице. С помощью логического программирования можно решить очень большое количество логических задач, написав при этом не более нескольких десятков строк кода. Но логическое программирование — это одна из парадигм программирования. Поэтому хорошо было бы рассказать о том, что такое программирование, какие есть парадигмы программирования и чем они друг от друга отличаются.

Программирование — это процесс написания компьютерной программы. Компьютерная программа — это набор команд, которые должен выполнить компьютер. У разных языков программирования разные требования к тому, как нужно писать команды и программу в целом (проще говоря, синтаксис). Синтаксис языка программирования описан так, чтобы машине было понятно, как и в какой последовательности выполнять те или иные действия. Простейшие программы могут состоять из около сотни строчек кода, а сложные программы могут состоять из даже более сотен тысяч строк. Код программы — это текст, в котором описан набор пошаговых инструкций. Он не обязательно состоит из нулей и единиц, в тексте кода могут встречаться символы или слова, только после компиляции (процесс преобразования программы, понятной человеку в программу, понятную машине) код будет содержать только нули и единицы. Только именно после компиляции компьютер считает и выполнит код. Если в тексте программы встретится опечатка или какая-нибудь ошибка (например, деление на ноль), то программа будет работать некорректно или вообще может не запуститься.
### Парадигмы программирования
Итак, что же такое парадигма программирования? Парадигма программирования — это идея того, как писать код, подход к тому, как писать программу. Есть огромное количество различных парадигм программирования, из которых особенно выделяются императивная, декларативная и логическая парадигмы. В императивной парадигме программирования программист записывает инструкции, которые нужно выполнить компьютеру в заданном программистом порядке. Пример программы на императивном языке программирования:

    1) пройти 2 метра вперед;
    2) если число четное, разделить его на два;
    3) вывести в консоль строку “Hello, World”.
    
Проще говоря, разработчик программы просто говорит компьютеру, что требуется выполнить и в каком порядке. Особенность императивной программы — это наличие понятия состояния программы или компьютера. Состояние программы — это набор данных (в такой набор данных может входить например переменная, массив, объект и так далее), которыми оперирует программа в какой-то конкретный момент времени. 
Программист при написании программы на декларативном языке программирования только лишь описывает саму задачу и какой результат он хочет получить. Получается, что в декларативной парадигме отпадает нужда в переменных, в состоянии и прочих понятиях, которые встречаются в императивной парадигме.

Вполне вероятно, что для бабушки или дедушки разница между декларативным и императивным подходами будет понятна интуитивно, но будет сложно составить простые программы на этих парадигмах. Допустим, требуется приготовить яичницу. В императивной парадигме мы просто выполняем порядок действий: поставь сковородку на огонь, возьми два куриных яйца, разбей их и так далее, то есть мы описываем, как добиться желаемого результата. В декларативной парадигме мы описываем какой именно результат нам нужен: — приготовь яичницу. И тот, кто получит это сообщение, уже сам разбирается, как её приготовить и какие шаги для этого нужно предпринять.
Но что нам предлагает логическая парадигма программирования? В данной парадигме программирования, в отличие от императивного подхода, вместо описания порядка действий, который должна совершить программа, описываются объекты, присутствующие в задаче, их различные свойства и отношения. Основным понятием в логической парадигме является отношение, которое образуется между несколькими объектами. Программа на логическом языке программирования состоит из таких отношений, называемых фактами, и правил (предикатов), создающих новые отношения. В ней не задается какого-либо алгоритма вычисления. Это в какой-то степени база данных о данной задаче, и как в базах данных, она выдает ответ на запросы. Ответ ищется с помощью логического вывода из имеющихся фактов и предикатов. Программа, которая занимается поиском решения, называется интерпретатором. 

Более формально, логическое программирование — это парадигма, в основе которой лежит автоматическое доказательство теорем и система знаний, изучающая основы логического вывода информации с помощью заданных правил вывода и фактов. Фундаментом логического программирования является математическая логика и в особенности такое понятие как правило резолюций — правило вывода, которое доказывает теоремы при помощи поиска противоречий. Самым популярным языком логического программирования является Prolog, на котором мы и будем обучать дедушку или бабушку логическому программированию.
### Математическая логика
Но для начала стоит объяснить, что такое математическая логика. В качестве ремарки я приведу историческую справку, взятую из источника [1]. «Формальная логика — одна из древнейших наук. Отдельные фрагменты ее начали разрабатываться в VI в. до нашей эры в Древней Греции и Индии. Основателем этой науки считается гениальный древнегреческий ученый Аристотель, который обстоятельно систематизировал логические формы и правила мышления, и тем самым заложил начала логики. Логика, основанная на учении Аристотеля, существовала до начала XX в., после чего в ней произошла своеобразная научная революция, связанная с широким применением методов так называемой символической, или математической логики. Идеи последней — о возможности сведения рассуждений к вычислениям — были высказаны еще немецким ученым Г. В. Лейбницем в XVII в. Однако только к началу XX столетия математическая логика (то есть логика, развиваемая математическим методом) оформилась в качестве самостоятельной дисциплины. Характерным для этой дисциплины является использование формальных языков с точным синтаксисом и четкой семантикой, однозначно определяющими понимание формул. Современная математическая логика — это та же самая логика Аристотеля, но только громоздкие словесные выводы 4 заменены в ней математической символикой. Эта дисциплина изучает вопросы применения математических методов для решения логических задач и построения логических схем, которые лежат в основе работы любого компьютера.» Высказывание в математической логике — предложение, выражающее суждение. Если суждение, составляющее смысл некоторого высказывания, истинно, то и о данном высказывании говорят, что оно истинно. Сходным образом ложным называют такое высказывание, которое является выражением ложного суждения. Чтобы понять, как устроен пролог, требуется понимать, как устроена простейшая логика предикатов.
Понятие «предикат» обобщает понятие «высказывание». Неформально говоря, предикат – это высказывание, в которое можно подставлять аргументы. Если аргумент один – то предикат выражает свойство аргумента, если больше – то отношение между аргументами. Пример предикатов. Возьмём высказывания: «Сократ - человек», «Платон - человек». Оба эти высказывания выражают свойство «быть человеком». Таким образом, мы можем рассматривать предикат «быть человеком» и говорить, что он выполняется для Сократа и Платона. Возьмём высказывание: «расстояние от Иркутска до Москвы 5 тысяч километров». Вместо него мы можем записать предикат «расстояние» (означающий, что первый и второй аргумент этого предиката находятся на расстоянии, равном третьему аргументу) для аргументов «Иркутск», «Москва» и «5 тысяч километров».
### Логические операции
Также, нужно показать простейшие логические операции: И, ИЛИ, и НЕ. Логическое И (Конъюнкция) — это логическая операция, истинная тогда и только тогда, когда, когда оба высказывания истинны. Например: 5 > 2 и 4 > 3 – истинно; 0 > -3 и 0 < 3 – ложно; Логическое ИЛИ (Дизъюнкция) — это логическая операция, ложная тогда и только тогда, когда, когда оба высказывания ложны. То есть, или истинно одно высказывание, или истинно другое, но не может быть такого, что они оба ложны. Отрицание (Инверсия) — это логическая операция, при которой истинное высказывание становится ложным, и наоборот. 
### Синтаксис языка
Теперь можно объяснить дедушке или бабушке, как же писать программы на прологе. Как и было сказано ранее для логической парадигмы, основные конструкции в языке Пролог это факт, процедура логического вывода (предикат), и запрос, на который отвечает интерпретатор. Терм — синтаксическая единица. Предложения в Прологе строятся из термов. Факт в Прологе задается логическим предикатом с конкретными аргументами. Совокупность фактов в базе данных представляются конкретными сведениями (знаниями). Обобщенные сведения получаются из логического вывода над фактами или обобщенными сведениями. Пример факта: Черный(Мяч).
Предикат в Прологе записывается следующем виде:
```prolog
X :- Y.
```
Эта запись означает, что если Y истинно, то и X истинно. Вроде бы всё просто и логично. Теперь нужно показать бабушке или дедушке, как можно просто строить более сложные факты (или, если говорить в терминах, обобщенные сведения). Например, нам бы хотелось узнать, является ли какой-нибудь объект (в данном примере мяч) и круглым и черным. Как тогда построить данный факт? Посмотрим, как построен текст задачи, а точнее, разобьем его на уже имеющиеся факты (конкретные сведения), и на союз между ними (в данном случае союз «и»). В предикате правила, написанные через запятую, как раз дают операцию логического И: X :- Y,Z. - такая запись означает, что из истинности X И Y следует истинность X. Итак, опишем требуемый предикат:
```prolog
черный_и_круглый(Объект):-  черный(Объект),
		  круглый(Объект).
```
Как просто и логично получилось! Такой пример особенно проиллюстрирует бабушке или дедушке, почему логическое программирование несет такое имя. Теперь можно перейти к чуть более сложным правилам в языке Prolog. 
Мы еще не рассмотрели две другие операции логики высказываний, о которых говорили ранее — о логическом ИЛИ и инверсии. Как их использовать? 

Инверсией (или проще говоря отрицанием) в языке Prolog выступает оператор \+. Его идея заключается в том, что следующий за ним предикат недоказуемый. По-другому этот оператор называют «оператором недоказуемости». Недоказуемость предиката означает, что программа не может доказать его истинность. Стоит пояснить, что при этом предикат необязательно должен быть ложным. Пример: 

```prolog
любой_кроме_белого(Объект):- \+ белый(Объект).
```

Также немаловажным является оператор отсечения (!). Если наш предикат определен следующим образом: Z :- X,!,Y. То это будет означать, если найдено какое-то решение, которое истинно для X, то дальнейший перебор производиться не будет. Этот оператор будет сложным для понимания, и его лучше понять на конкретном примере, который будет рассмотрен в дальнейшем, когда я буду обсуждать, как именно интерпретатор находит решения.

Остался оператор логического ИЛИ. В прологе данный оператор описывается следующим образом: (X; Y) – истинно или X, или Y. При этом данный оператор можно использовать в связке с логическим И. Стоит объяснить бабушке или дедушке как их использовать на конкретном примере. Допустим, задача стоит так: определить предикат, который выясняет, лежит ли число или в интервале (1;2), или в интервале (3;4). Следуя алгоритму решения, описанному выше, получаем, что у нас есть два факта (число лежит в (1;2), или лежит в (3;4)), и союз (операция) или. Тут всё понятно. Но как описать эти два факта? Очевидно, что прописывать каждому числу факт принадлежности интервалу в программе не самая лучшая идея (чисел-то очень много придется брать из этого интервала, и даже если мы описали какой-нибудь набор чисел, можно придумать число, не входящее в этот набор). Давайте рассмотрим поближе предикат принадлежности интервалу (a;b). Он означает то, что число «лежит» в нем, то есть оно меньше b и больше a. Теперь мы можем попытаться формально сформулировать наш предикат: или число меньше 2 и больше 1 или число меньше 4 и больше 3. Опишем данный предикат на языке Пролог:
```prolog
число_в_1;2_или_в_3;4(число):-  (число < 2,число > 1);
		  (число < 4,число > 3).
```
      
### Списки
Итак, пришло время рассказать о списках. Списки очень важная структура, редко когда сколь сложная задача обходится без их использования. Где мы встречаем списки в реальной жизни? Например, когда составляем список покупки продуктов. И что удивительно, список продуктов в прологе будет выглядеть примерно так же, как и на листке! Возьмем конкретный пример списка:
	Купить:
  
		1. Батон хлеба;
		2. Сыр;
		3. Молоко;
		4. Колбасу.
    
Этот же список, но на языке Prolog:
```prolog
	купить([‘Батон хлеба’, ‘Сыр’, ‘Молоко’, ‘Колбасу“]).
```	
То есть, элементы списка заключаются в квадратные скобки и пишутся через запятую, причем порядок их следования важен (то есть батон хлеба всё так же на первом месте, потом сыр и так далее). В данном примере данный список «облачен» в факт «купить», который, как можно догадаться, определяет, что нужно купить.
У нас есть такая структура, как список, отлично, а что с ней можно делать? Или, если более формально, какие предикаты для работы с ней существует в языке Prolog? Сначала посмотрим, как нам «пройти» по списку (то есть посмотреть первый элемент, потом второй и так далее). На помощь нам приходит следующая замечательная запись: [H|T]. Эта запись означает, что список — это объединение элемента H и всего остального списка T без H. Для примера выше H = ‘Батон хлеба’, T = [‘Сыр’, ‘Молоко’, ‘Колбасу“]. Для списка из одного элемента T будет пустым списком (в Прологе такие списки существуют и обозначаются просто []), а H будет равен этому элементу (например, для списка [x] H = x и T =[]). Попрактикуемся в использовании списков на конкретной задаче: требуется составить предикат, который последовательно выводит все элементы на экран. Вероятнее всего, бабушка или дедушка не смогут сами решить эту задачу, если им не подсказать. Стоит начать с малого: что будет, если на вход к предикату будет подан пустой список? Выводить конечно ничего не придётся. Поэтому опишем следующее правило:
написать([]).
	
Теперь вспомним запись [H|T]. Наверняка она как-то замешана в этой задаче. Напомним им, что H – элемент, тогда почему бы нам его не вывести? Хорошо, мы его напечатали, а что делать с оставшимся списком T? И тут будет момент осознания: в правиле можно использовать то же самое правило, таким образом бабушка или дедушка наглядно познакомятся с принципом рекурсии (в данном случае она будет хвостовой, но им это не так уж и обязательно знать, хотя и можно рассказать). В конце концов опишем сам предикат:
```prolog
написать([H|T]):-  print(H),
		  написать(T).
```
И это всё! Достаточно просто и наглядно. Расскажем про самые часто используемые стандартные предикаты. length(L, X) – X длина списка L;  memberchk(L, X) – X элемент списка L; append(L1, L2, L) – L – объединение списков L1 и L2.

### Решение конкретной задачи

Рассмотренные ранее примеры конечно довольно познавательные, но они высосаны из пальца, поэтому у бабушки или дедушки встанет очевидный вопрос: в каких конкретных задачах пролог пригодится и как с его помощью решать эти задачи?
Как мне кажется, задача, которую я решал во второй лабораторной работе, отлично подходит для иллюстрации того, как можно с помощью пролога решать конкретные логические задачи. Более того, она очень простая и её решение не занимает много места, таким образом бабушка или дедушка с высокой долью вероятности смогут самостоятельно её решить. Приведу условие задачи[2]: “Как то раз случай свел в купе астронома, поэта , прозаика и драматурга. Это были Алексеев, Борисов, Константинов и Дмитриев. Оказалось, что каждый из них взял с собой книгу написанную одним из пассажиров этого купе. Алексеев и Борисов углубились в чтение предварительно обменявшись книгами. Поэт читал пьесу, прозаик - очень молодой человек, выпустившись свою книгу, говорил что он никогда и ни чего не читал по астрономии. Борисов купил одно из произведений Дмитриева. Никто из пассажиров не читал свои книги. Что читал каждый из них, кто кем был?”
Воспользуемся тем же самым алгоритмом, который использовали для решения предыдущих примеров: разбиение на факты и соотношения между ними. Мы будем читать по предложению и пытаться перевести его на язык пролога. Начнем с малого: определим, какие книги вообще есть:
```prolog
book(„astronomy“).
book(„poetry“).
book(„prose“).
book(„piece“).
```
Решение запишем в виде списка пассажиров, каждый пассажир по сути задается 4 параметрами: его имя, что он читал, что купил, и что написал:
```prolog
S = [passenger(„Alekseev“, XR, XB, XW), passenger(„Borisov“, YR, YB, YW),
          passenger(„Konstantinov“, ZR, ZB, ZW), passenger(„Dmitriev“, WR, WB, WW)],
```
 Каждый написал книгу, купил книгу и читает книгу, причем, судя по предпоследнему предложению, у каждого книга, которую он читает, не совпадает с книгой, которую он написал, и аналогично у каждого книга, которую он читает, не совпадает с книгой, которую он написал:
 ```prolog
book(XW), book(YW),
  book(ZW), book(WW),
  unique([XW, YW, ZW, WW]),
  book(XB), book(YB),
  book(ZB), book(WB),
  unique([XB, YB, ZB, WB]),
  book(XR), book(YR),
  book(ZR), book(WR),
  unique([XR, YR, ZR, WR]),
```

Читаем дальше, Алексеев и Борисов обменялись книгами, запишем это:
```prolog
member(passenger(„Alekseev“, AR, AB, _), S),
 member(passenger(„Borisov“, AB, AR, _), S),
```
Поэт читал пьесу, а прозаик точно не читал и не покупал книгу по астрономии:
```prolog
member(passenger(_, „piece“, _, „poetry“), S),
  not(member(passenger(_, „astronomy“, _, „prose“), S)),
  not(member(passenger(_, _, „astronomy“, „prose“), S)),
```
Борисов купил произведение Дмитриева:
```prolog
 member(passenger(„Dmitriev“, _, _, DW), S),
 member(passenger(„Borisov“, _, DW, _), S),
```
И, в конце концов,  никто из пассажиров не читал свои книги. Проверку этого утверждения вынесем в отдельный предикат, который внешне очень похож на предикат, который мы писали для печати списка:
```prolog
check([]):-!.
check([passenger(_, XR, XB, XW)|T]):-
  !, \+ XR = XW, \+ XB = XW, check(T).
```
И в результате нам осталось всего лишь сделать проверку этого предиката:
```prolog
check(S).
```
И на самом деле это вся задача. Всё, что мы сделали, это лишь описали отношения в «мире» самой задачи, мы не указывали как её решать, как и говорилось ранее, интерпретатор сам решит её за нас. Посмотрим на результат работы:
```prolog
? - solve ( X ). 
X = [ passenger ( „Alekseev“ , „prose“ , „piece“ , „astronomy“ ) , passenger ( „Borisov“ , „piece“ , „prose“ , „poetry“ ) , passenger ( „Konstantinov“ , „astronomy“ , „astronomy“ , „piece“ ) , passenger ( „Dmitriev“ , „poetry“ , „poetry“ , „prose“ )] 
X = [ passenger ( „Alekseev“ , „piece“ , „prose“ , „poetry“ ), passenger ( „Borisov“ , „prose“ , „piece“ , „astronomy“ ) , passenger ( „Konstantinov“ , „poetry“ , „poetry“ , „prose“ ) , passenger ( „Dmitriev“ , „astronomy“ , „astronomy“ , „piece“ )] 
```
В качестве дополнительного задания можно попросить дедушку или бабушку самостоятельно проверить эти решения.
### Вывод
Было очень интересно попробовать себя в роли педагога, составлять материал, отвечать (хоть и на свои) вопросы, подбирать примеры так, чтобы они отразили суть того или иного явления как можно глубже. Конечно хотелось бы попробовать обучить бабушку или дедушку по данному «руководству», но скорее всего это не увенчалось бы успехом: возможно они и поняли бы основные идеи и синтаксис языка Prolog, но этого всё равно недостаточно, чтобы научиться программировать. Для этого нужно потратить больше времени и сил, что у старшего поколения точно не в достатке. В целом же в процессе написания реферата я повторил свои знания логического программирования.

### Источники
[1] - http://www.rstu.ru/metods/books/matlog2011.pdf

[2] - http://www.soshnikov.com/courses/prolog/labs/lab2.pdf

[3] - http://www.mari-el.ru/mmlab/home/prolog/
